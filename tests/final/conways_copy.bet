# Wrapper class that allows printable 2D Arrays
struct printable_arr(arr::[[int]], printer::([[int]])->unit);

# Prints 2D Arrays
fun print_arr(arr::[[int]])::unit {
    let (i := 0) {
        do {
            print(arr[i]);
            i := i + 1;
        } until (i >= (arr_len(arr)));
    };
};

fun format_print(x::printable_arr)::unit {
    (x.printer)(x.arr);
};

# Populate array cells
# Code automatically generated by python script
fun populate_array(arr::[[int]])::unit {
    arr[0][0] := 1; 
    arr[0][1] := 1; 
    arr[0][2] := 1; 
    arr[0][3] := 0; 
    arr[0][4] := 1;
    arr[1][0] := 0;
    arr[1][1] := 1;
    arr[1][2] := 1;
    arr[1][3] := 0;
    arr[1][4] := 0;
    arr[2][0] := 1;
    arr[2][1] := 1;
    arr[2][2] := 1;
    arr[2][3] := 0;
    arr[2][4] := 1;
    arr[3][0] := 1;
    arr[3][1] := 0;
    arr[3][2] := 1;
    arr[3][3] := 0;
    arr[3][4] := 1;
    arr[4][0] := 1;
    arr[4][1] := 1;
    arr[4][2] := 1;
    arr[4][3] := 0;
    arr[4][4] := 1;
};

# Initialize and setup a printable array
fun setup_printable_arr(n::int, populate::bool)::printable_arr {
    let (x := (new printable_arr), i := 0) {
        # Initialize 2D Array
        x.arr := (new_arr([int], n));
        do {
            x.arr[i] := (new_arr(int, n));
            i := i + 1;
        } until (i >= n);

        # If the array should be populated, do so
        if (populate) {
            populate_array(x.arr);
        } else {
            x.arr;
        };

        # Attatch print function and return
        x.printer := print_arr;
        x
    }
};

# Checks if value is within bounds
fun check_bounds(v::int, upper_bound::int)::bool {
    (v >= 0) && (v < upper_bound)
};

# Counts neighbors of a specific cell
fun count_neighbors(arr::[[int]], i::int, j::int)::int {
    let (
        m := arr_len(arr),
        n := arr_len(arr[0]),
        i_off := ~1,
        j_off := ~1,
        t := 0
    ) {
        do {
            j_off := ~1;
            do {
                if ((i_off == 0) && (j_off == 0)) {
                    t := t;
                } else {
                    if ((check_bounds(i + i_off, m)) && (check_bounds(j + j_off, n))) {
                        if ((arr[i + i_off][j + j_off]) == 1) {
                            t := t + 1;
                        } else {
                            t := t;
                        };
                    } else {
                        t := t;
                    };
                };
                j_off := j_off + 1;
            } until (j_off >= 2);
            i_off := i_off + 1;
        } until (i_off >= 2);
        t
    }
};

# Cell update logic for Conway's Game of Life
fun step_cell(arr::[[int]], i::int, j::int)::int {
    let (neighbors := count_neighbors(arr, i, j)) {
        if ((arr[i][j]) == 0) {
            if (neighbors == 3) {
                1
            } else {
                0
            }
        } else {
            if ((neighbors == 2) || (neighbors == 3)) {
                1
            } else {
                0
            }
        }
    }
};

fun step_all(arr::[[int]], temp_arr::[[int]])::unit {
    let (i := 0, j := 0) {
        do {
            j := 0;
            do {
                temp_arr[i][j] := (step_cell(arr, i, j));
                j := j + 1;
            } until(j >= (arr_len(arr[0])));
            i := i + 1;
        } until (i >= (arr_len(arr)));
    };

    let (i := 0, j := 0) {
        do {
            j := 0;
            do {
                arr[i][j] := (temp_arr[i][j]);
                j := j + 1;
            } until(j >= (arr_len(arr[0])));
            i := i + 1;
        } until (i >= (arr_len(arr)));
    };
};

let (
    arr_size := 5,
    cells := setup_printable_arr(arr_size, true), 
    temp_cells := setup_printable_arr(arr_size, false),
    t := 0
) {
    do {
        print(t);
        format_print(cells, t);
        step_all(cells.arr, temp_cells.arr);
        t := t + 1;
    } until(t > input);
    t
}