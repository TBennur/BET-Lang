; A program that illustrates how your language enables the creation of binary 
; search trees, and implements functions to add an element and check if an 
; element is in the tree. Include several tests that print example output from
; calling these functions.

(struct bst ((val int) (left bst) (right bst)))

(fun newBST () bst (alloc bst))

(fun setVal ((tree bst) (newVal int)) bst 
    (block 
        (update tree val newVal)
        tree
    )
)

(fun setLeft ((tree bst) (newLeft bst)) bst 
    (block 
            (update tree left newLeft)
            tree
        
    )
)

(fun setRight ((tree bst) (newRight bst)) bst 
    (block 
            (update tree right newRight)
            tree
        
    )
)

(fun search ((tree bst) (searchVal int)) bst 
    (
        if 
            (= tree (null bst))
            (null bst)
            (
                let 
                (
                    (cur (lookup tree val))
                )
                (if 
                    (= cur searchVal) 
                    tree
                    (if 
                        (< cur searchVal)
                        (search (lookup tree right) searchVal)
                        (search (lookup tree left) searchVal)
                    )
                )
        )
   )
)

(fun addTree ((tree bst) (newVal int)) bst 
    (if 
        (= tree (null bst))
        (let 
            ((newTree (newBST)))
            (block
                (update newTree val newVal)
                newTree
            )   
        )                         
        (
            let 
            (
                (cur (lookup tree val))
            )
            (if 
                (= cur newVal) 
                tree 
                (if 
                    (< cur newVal)
                    (if 
                        (= (lookup tree right) (null bst))
                        (block 
                            (update tree right (newBST))
                            (update (lookup tree right) val newVal)
                            tree
                        )
                        (block
                            (update tree right (addTree (lookup tree right) newVal))
                            tree
                        )
                    )
                    (if 
                        (= (lookup tree left) (null bst))
                        (block  
                            (update tree left (newBST))
                            (update (lookup tree left) val newVal)
                            tree
                        )
                        (block
                            (update tree left (addTree (lookup tree left) newVal))
                            tree
                        )
                    )
                )
            )
        )
    )
)

(
    let
        ((x (null bst)))
        (block
            (set! x (addTree x 4))
            (print x)
            (print (lookup x left))
            (print (lookup x right))
            (set! x (addTree x 3))
            (print x)
            (print (lookup x left))
            (print (lookup x right))
            (set! x (addTree x 2))
            (print x)
            (print (lookup x left))
            (print (lookup x right))
            (set! x (addTree x 5))
            (print x)
            (print (lookup x left))
            (lookup x right)
        )
)
