import numpy as np
import sys
import os
import shutil
import tempfile

from matplotlib import pyplot as plt
from PIL import Image

DENSITY = 0.6

FILE_1 = """
 # Wrapper class that allows printable 2D Arrays
struct printable_arr(arr::[[int]], printer::([[int]])->unit);

# Prints 2D Arrays
fun print_arr(arr::[[int]])::unit {
    let (i := 0) {
        do {
            print(arr[i]);
            i := i + 1;
        } until (i >= (arr_len(arr)));
    };
};

fun format_print(x::printable_arr)::unit {
    (x.printer)(x.arr);
};

# Populate array cells
# Code automatically generated by python script
fun populate_array(arr::[[int]])::unit {
"""


FILE_2 = """
};

# Initialize and setup a printable array
fun setup_printable_arr(n::int, populate::bool)::printable_arr {
    let (x := (new printable_arr), i := 0) {
        # Initialize 2D Array
        x.arr := (new_arr([int], n));
        do {
            x.arr[i] := (new_arr(int, n));
            i := i + 1;
        } until (i >= n);

        # If the array should be populated, do so
        if (populate) {
            populate_array(x.arr);
        } else {
            x.arr;
        };

        # Attatch print function and return
        x.printer := print_arr;
        x
    }
};

# Checks if value is within bounds
fun check_bounds(v::int, upper_bound::int)::bool {
    (v >= 0) && (v < upper_bound)
};

# Counts neighbors of a specific cell
fun count_neighbors(arr::[[int]], i::int, j::int)::int {
    let (
        m := arr_len(arr),
        n := arr_len(arr[0]),
        i_off := ~1,
        j_off := ~1,
        t := 0
    ) {
        do {
            j_off := ~1;
            do {
                if ((i_off == 0) && (j_off == 0)) {
                    t := t;
                } else {
                    if ((check_bounds(i + i_off, m)) && (check_bounds(j + j_off, n))) {
                        if ((arr[i + i_off][j + j_off]) == 1) {
                            t := t + 1;
                        } else {
                            t := t;
                        };
                    } else {
                        t := t;
                    };
                };
                j_off := j_off + 1;
            } until (j_off >= 2);
            i_off := i_off + 1;
        } until (i_off >= 2);
        t
    }
};

# Cell update logic for Conway's Game of Life
fun step_cell(arr::[[int]], i::int, j::int)::int {
    let (neighbors := count_neighbors(arr, i, j)) {
        if ((arr[i][j]) == 0) {
            if (neighbors == 3) {
                1
            } else {
                0
            }
        } else {
            if ((neighbors == 2) || (neighbors == 3)) {
                1
            } else {
                0
            }
        }
    }
};

fun step_all(arr::[[int]], temp_arr::[[int]])::unit {
    let (i := 0, j := 0) {
        do {
            j := 0;
            do {
                temp_arr[i][j] := (step_cell(arr, i, j));
                j := j + 1;
            } until(j >= (arr_len(arr[0])));
            i := i + 1;
        } until (i >= (arr_len(arr)));
    };

    let (i := 0, j := 0) {
        do {
            j := 0;
            do {
                arr[i][j] := (temp_arr[i][j]);
                j := j + 1;
            } until(j >= (arr_len(arr[0])));
            i := i + 1;
        } until (i >= (arr_len(arr)));
    };
};

let (
    arr_size := """


FILE_3 = """,
    cells := setup_printable_arr(arr_size, true), 
    temp_cells := setup_printable_arr(arr_size, false),
    t := 0
) {
    do {
        print(t);
        format_print(cells);
        step_all(cells.arr, temp_cells.arr);
        t := t + 1;
    } until(t > input);
    t
}
"""



## Some helper functions for visualization and submission
def visualize_state(state, title=None, file_path=None):
    """
    Visualize the 2D state as an image.
    
    Parameters:
        state (np.ndarray): the 2D state to be visualized
        title (str, optional): the title of the plot
        file_path (str, optional): the path to save the image
    """
    assert isinstance(state, np.ndarray)

    N, M = state.shape
    X, Y = np.meshgrid(range(N + 1), range(M + 1))
    ax = plt.axes()
    ax.imshow(state, "binary", vmin=-1, vmax=1)
    plt.setp(ax.get_yticklabels(), visible=False)
    plt.setp(ax.get_xticklabels(), visible=False)      
    
    if title is not None:
        plt.title(title)
    plt.axis('tight')
    if file_path is not None:
        plt.savefig(file_path)
    else:
        plt.show()
    plt.clf()


def generate_gif(samples, output_path, image_dir=None):
    """
    Generate a GIF using collected samples (not required)
    
    Parameters:
        samples (List of np.ndarray): the list of samples
        output_path: the path to save the GIF
        image_dir (optional): the directory for saving the images,
            if not provided, the images will be removed afterwards
    """
    if image_dir is None:
        image_dir = tempfile.mkdtemp()
        rm_flag = True
    else:
        if not os.path.exists(image_dir):
            os.makedirs(image_dir)
        rm_flag = False
        
    for i, sample in enumerate(samples):
        visualize_state(sample, f"Time={i}", f"{image_dir}/{i}.png")
    
    images = []
    for i in range(len(samples)):
        images.append(Image.open(f"{image_dir}/{i}.png"))
        
    images[0].save(
        output_path,
        save_all=True,
        append_images=images[1:],
        duration=50)
    
    if rm_flag:
        shutil.rmtree(image_dir)

def generate(dim):
    nums = np.random.choice([0, 1], size=(dim**2), p=[1 - DENSITY, DENSITY])
    cells = nums.reshape((dim, dim))
    assignations = []

    for i in range(dim):
        for j in range(dim):
            assignations.append(f"\tarr[{i}][{j}] := {cells[i, j]};")

    generated_file = (FILE_1 + "\n".join(assignations) + FILE_2 + str(dim) +
                      FILE_3)
    with open("tests/final/conways.bet", "w") as file:
        file.write(generated_file)


def visualize(filename):
    # Open output file
    f = open(filename, "r")

    # Build cell log from frames
    frames = []
    rows = []
    i = 0
    f.readline()
    # Loop through output file
    for file_row in f:
        i += 1
        f = file_row.strip()
        if f != "":
            if f[0] != "[":
                frames.append(np.stack(rows))
                rows = []
            row = file_row[1:-2].split(", ")
            if len(row) <= 1:
                continue
            rows.append(np.array([int(cell) for cell in row]))
 
    generate_gif(frames, "./conway.gif")


if __name__ == "__main__":

    mode = sys.argv[2]
    if mode == "visualize":
        visualize("output.txt")
    elif mode == "generate":
        dim = int(sys.argv[4])
        generate(dim)
    else:
        print("Unknown Mode: ", mode)
